<!doctype html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android,View,Event Dispatch," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="前面我们分析了View的Measure，Layout和Draw的过程，这样View就被显示到屏幕上了，但是仅仅是显示是不够的，我们还要和View交互，一般界面都有不少View，从手指按下后，系统是怎么确定该是哪个View去响应的呢？我们今天就从源码中查找答案。">
<meta property="og:type" content="article">
<meta property="og:title" content="View源码了解一下，事件分发逻辑">
<meta property="og:url" content="http://yoursite.com/View源码了解一下，事件分发逻辑/index.html">
<meta property="og:site_name" content="brainBear' Blog">
<meta property="og:description" content="前面我们分析了View的Measure，Layout和Draw的过程，这样View就被显示到屏幕上了，但是仅仅是显示是不够的，我们还要和View交互，一般界面都有不少View，从手指按下后，系统是怎么确定该是哪个View去响应的呢？我们今天就从源码中查找答案。">
<meta property="og:updated_time" content="2018-05-30T08:37:52.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="View源码了解一下，事件分发逻辑">
<meta name="twitter:description" content="前面我们分析了View的Measure，Layout和Draw的过程，这样View就被显示到屏幕上了，但是仅仅是显示是不够的，我们还要和View交互，一般界面都有不少View，从手指按下后，系统是怎么确定该是哪个View去响应的呢？我们今天就从源码中查找答案。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/View源码了解一下，事件分发逻辑/"/>





  <title> View源码了解一下，事件分发逻辑 | brainBear' Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">brainBear' Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/View源码了解一下，事件分发逻辑/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="brainBear">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="brainBear' Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="brainBear' Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                View源码了解一下，事件分发逻辑
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-27T17:02:32+08:00">
                2018-05-27
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>前面我们分析了View的Measure，Layout和Draw的过程，这样View就被显示到屏幕上了，但是仅仅是显示是不够的，我们还要和View交互，一般界面都有不少View，从手指按下后，系统是怎么确定该是哪个View去响应的呢？我们今天就从源码中查找答案。<br><a id="more"></a></p>
<h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p>我们先从Activity开始，首先调用的是dispatchTouchEvent方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class="line">    if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">        onUserInteraction();</div><div class="line">    &#125;</div><div class="line">    if (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    return onTouchEvent(ev);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先判断是不是ACTION_DOWN事件，如果是就调用onUserInteraction方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public void onUserInteraction() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Activity中的onUserInteraction方法是空实现的，文档注释写着说当有按键、触摸、或者轨迹球事件分发到Activity的话就回调这个方法，如果我们想知道用户是否与设备产生交互的时候就可以重写这个方法。</p>
<p>然后就会调用getWindow方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Window getWindow() &#123;</div><div class="line">    return mWindow;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码只是简单返回了mWindow这个变量，我们查查这个变量是哪里赋值的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">final void attach(Context context, ActivityThread aThread,</div><div class="line">        Instrumentation instr, IBinder token, int ident,</div><div class="line">        Application application, Intent intent, ActivityInfo info,</div><div class="line">        CharSequence title, Activity parent, String id,</div><div class="line">        NonConfigurationInstances lastNonConfigurationInstances,</div><div class="line">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</div><div class="line">        Window window, ActivityConfigCallback activityConfigCallback) &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    mWindow = new PhoneWindow(this, window, activityConfigCallback);</div><div class="line">    </div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>mWindow只会在Activity的attach方法赋值，我们也找到了mWindow是PhoneWindow的实例，所以我们继续看PhoneWindow的superDispatchTouchEvent方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</div><div class="line">    return mDecor.superDispatchTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里就是调用了mDecor的superDispatchTouchEvent方法。mDecor是DecorView的实例，而DecorView的superDispatchTouchEvent是继承于FrameLayout的，而FrameLayout又继承与ViewGroup，所以我们需要去ViewGroup中寻找答案。</p>
<h2 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class="line">    if (mInputEventConsistencyVerifier != null) &#123;</div><div class="line">        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // If the event targets the accessibility focused view and this is it, start</div><div class="line">    // normal event dispatch. Maybe a descendant is what will handle the click.</div><div class="line">    if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</div><div class="line">        ev.setTargetAccessibilityFocus(false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    boolean handled = false;</div><div class="line">		</div><div class="line">    //安全性校验</div><div class="line">    if (onFilterTouchEventForSecurity(ev)) &#123;</div><div class="line">        final int action = ev.getAction();</div><div class="line">        final int actionMasked = action &amp; MotionEvent.ACTION_MASK;</div><div class="line"></div><div class="line">        // Handle an initial down.</div><div class="line">        if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">            // Throw away all previous state when starting a new touch gesture.</div><div class="line">            // The framework may have dropped the up or cancel event for the previous gesture</div><div class="line">            // due to an app switch, ANR, or some other state change.</div><div class="line"></div><div class="line">            //ACTIONN_DOWN事件清除旧的状态，主要是清除mFirstTouchTarget和FLAG_DISALLOW_INTERCEPT标志位</div><div class="line">            cancelAndClearTouchTargets(ev);</div><div class="line">            resetTouchState();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Check for interception.</div><div class="line">        final boolean intercepted;</div><div class="line">        if (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                || mFirstTouchTarget != null) &#123;</div><div class="line">	</div><div class="line">                //子View可以调用getParent().requestDisallowInterceptTouchEvent()这个方法设置父View的FLAG_DISALLOW_INTERCEPT</div><div class="line">            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</div><div class="line">            if (!disallowIntercept) &#123;</div><div class="line">	</div><div class="line">                //一般都是重写onInterceptTouchEvent来处理是否拦截该事件</div><div class="line">                intercepted = onInterceptTouchEvent(ev);</div><div class="line">                ev.setAction(action); // restore action in case it was changed</div><div class="line">            &#125; else &#123;</div><div class="line">                intercepted = false;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            // There are no touch targets and this action is not an initial down</div><div class="line">            // so this view group continues to intercept touches.</div><div class="line">            intercepted = true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // If intercepted, start normal event dispatch. Also if there is already</div><div class="line">        // a view that is handling the gesture, do normal event dispatch.</div><div class="line">        if (intercepted || mFirstTouchTarget != null) &#123;</div><div class="line">            ev.setTargetAccessibilityFocus(false);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Check for cancelation.</div><div class="line">        final boolean canceled = resetCancelNextUpFlag(this)</div><div class="line">                || actionMasked == MotionEvent.ACTION_CANCEL;</div><div class="line"></div><div class="line">        // Update list of touch targets for pointer down, if needed.</div><div class="line">        final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;</div><div class="line">        TouchTarget newTouchTarget = null;</div><div class="line">        boolean alreadyDispatchedToNewTouchTarget = false;</div><div class="line">        if (!canceled &amp;&amp; !intercepted) &#123;</div><div class="line"></div><div class="line">            // If the event is targeting accessiiblity focus we give it to the</div><div class="line">            // view that has accessibility focus and if it does not handle it</div><div class="line">            // we clear the flag and dispatch the event to all children as usual.</div><div class="line">            // We are looking up the accessibility focused host to avoid keeping</div><div class="line">            // state since these events are very rare.</div><div class="line">            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</div><div class="line">                    ? findChildWithAccessibilityFocus() : null;</div><div class="line"></div><div class="line">            if (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</div><div class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class="line">                final int actionIndex = ev.getActionIndex(); // always 0 for down</div><div class="line">                final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)</div><div class="line">                        : TouchTarget.ALL_POINTER_IDS;</div><div class="line"></div><div class="line">                // Clean up earlier touch targets for this pointer id in case they</div><div class="line">                // have become out of sync.</div><div class="line">                removePointersFromTouchTargets(idBitsToAssign);</div><div class="line"></div><div class="line">                final int childrenCount = mChildrenCount;</div><div class="line">                if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;</div><div class="line">                    final float x = ev.getX(actionIndex);</div><div class="line">                    final float y = ev.getY(actionIndex);</div><div class="line">                    // Find a child that can receive the event.</div><div class="line">                    // Scan children from front to back.</div><div class="line">		</div><div class="line">                    //对全部子View排序</div><div class="line">                    final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</div><div class="line">                    final boolean customOrder = preorderedList == null</div><div class="line">                            &amp;&amp; isChildrenDrawingOrderEnabled();</div><div class="line">                    final View[] children = mChildren;</div><div class="line">                    for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</div><div class="line">                        final int childIndex = getAndVerifyPreorderedIndex(</div><div class="line">                                childrenCount, i, customOrder);</div><div class="line">                        final View child = getAndVerifyPreorderedView(</div><div class="line">                                preorderedList, children, childIndex);</div><div class="line"></div><div class="line">                        // If there is a view that has accessibility focus we want it</div><div class="line">                        // to get the event first and if not handled we will perform a</div><div class="line">                        // normal dispatch. We may do a double iteration but this is</div><div class="line">                        // safer given the timeframe.</div><div class="line">                        if (childWithAccessibilityFocus != null) &#123;</div><div class="line">                            if (childWithAccessibilityFocus != child) &#123;</div><div class="line">                                continue;</div><div class="line">                            &#125;</div><div class="line">                            childWithAccessibilityFocus = null;</div><div class="line">                            i = childrenCount - 1;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">			</div><div class="line">                        //判断这个View能否接收这个事件，判断依据是View是否可见或者正在动画中而且触摸事件的坐标在View位置上</div><div class="line">                        if (!canViewReceivePointerEvents(child)</div><div class="line">                                || !isTransformedTouchPointInView(x, y, child, null)) &#123;</div><div class="line">                            ev.setTargetAccessibilityFocus(false);</div><div class="line">                            continue;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        newTouchTarget = getTouchTarget(child);</div><div class="line">                        if (newTouchTarget != null) &#123;</div><div class="line">                            // Child is already receiving touch within its bounds.</div><div class="line">                            // Give it the new pointer in addition to the ones it is handling.</div><div class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        resetCancelNextUpFlag(child);</div><div class="line">			</div><div class="line">                        //将事件分发给子View</div><div class="line">                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</div><div class="line">                            // Child wants to receive touch within its bounds.</div><div class="line">                            mLastTouchDownTime = ev.getDownTime();</div><div class="line">                            if (preorderedList != null) &#123;</div><div class="line">                                // childIndex points into presorted list, find original index</div><div class="line">                                for (int j = 0; j &lt; childrenCount; j++) &#123;</div><div class="line">                                    if (children[childIndex] == mChildren[j]) &#123;</div><div class="line">                                        mLastTouchDownIndex = j;</div><div class="line">                                        break;</div><div class="line">                                    &#125;</div><div class="line">                                &#125;</div><div class="line">                            &#125; else &#123;</div><div class="line">                                mLastTouchDownIndex = childIndex;</div><div class="line">                            &#125;</div><div class="line">                            mLastTouchDownX = ev.getX();</div><div class="line">                            mLastTouchDownY = ev.getY();</div><div class="line">                   </div><div class="line">                            //如果子View处理了该事件，则对newTouchTarget和mFirstTouchTarget赋值</div><div class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">				</div><div class="line">                            //alreadyDispatchedToNewTouchTarget赋值为true</div><div class="line">                            alreadyDispatchedToNewTouchTarget = true;</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        // The accessibility focus didn&apos;t handle the event, so clear</div><div class="line">                        // the flag and do a normal dispatch to all children.</div><div class="line">                        ev.setTargetAccessibilityFocus(false);</div><div class="line">                    &#125;</div><div class="line">                    if (preorderedList != null) preorderedList.clear();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123;</div><div class="line">                    // Did not find a child to receive the event.</div><div class="line">                    // Assign the pointer to the least recently added target.</div><div class="line">                    newTouchTarget = mFirstTouchTarget;</div><div class="line">                    while (newTouchTarget.next != null) &#123;</div><div class="line">                        newTouchTarget = newTouchTarget.next;</div><div class="line">                    &#125;</div><div class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Dispatch to touch targets.</div><div class="line">			</div><div class="line">        //如果没有子View处理该事件则自己处理，注意第三个参数是null</div><div class="line">        if (mFirstTouchTarget == null) &#123;</div><div class="line">            // No touch targets so treat this as an ordinary view.</div><div class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, null,</div><div class="line">                    TouchTarget.ALL_POINTER_IDS);</div><div class="line">        &#125; else &#123;</div><div class="line">            // Dispatch to touch targets, excluding the new touch target if we already</div><div class="line">            // dispatched to it.  Cancel touch targets if necessary.</div><div class="line">            TouchTarget predecessor = null;</div><div class="line">            TouchTarget target = mFirstTouchTarget;</div><div class="line">            while (target != null) &#123;</div><div class="line">                final TouchTarget next = target.next;</div><div class="line">                if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</div><div class="line">                    handled = true;</div><div class="line">                &#125; else &#123;</div><div class="line">                    final boolean cancelChild = resetCancelNextUpFlag(target.child)</div><div class="line">                            || intercepted;</div><div class="line">				</div><div class="line">                    //继续分发事件</div><div class="line">                    if (dispatchTransformedTouchEvent(ev, cancelChild,</div><div class="line">                            target.child, target.pointerIdBits)) &#123;</div><div class="line">                        handled = true;</div><div class="line">                    &#125;</div><div class="line">                    if (cancelChild) &#123;</div><div class="line">                        if (predecessor == null) &#123;</div><div class="line">                            mFirstTouchTarget = next;</div><div class="line">                        &#125; else &#123;</div><div class="line">                            predecessor.next = next;</div><div class="line">                        &#125;</div><div class="line">                        target.recycle();</div><div class="line">                        target = next;</div><div class="line">                        continue;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                predecessor = target;</div><div class="line">                target = next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Update list of touch targets for pointer up or cancel, if needed.</div><div class="line">        if (canceled</div><div class="line">                || actionMasked == MotionEvent.ACTION_UP</div><div class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class="line">            resetTouchState();</div><div class="line">        &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</div><div class="line">            final int actionIndex = ev.getActionIndex();</div><div class="line">            final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);</div><div class="line">            removePointersFromTouchTargets(idBitsToRemove);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123;</div><div class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);</div><div class="line">    &#125;</div><div class="line">    return handled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码比较长，而且逻辑也比较复杂，我们一步步看，首先需要确定一件事情，就是当dispatchTouchEvent方法返回true的话，代表这个事件被消费了，如果返回false，则证明这个事件没有被处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class="line">   </div><div class="line">   ...</div><div class="line"></div><div class="line">    boolean handled = false;</div><div class="line">		</div><div class="line">    //安全性校验</div><div class="line">    if (onFilterTouchEventForSecurity(ev)) &#123;</div><div class="line">        </div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return handled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>handled就是最后的返回值，我们就从handled入手，如果onFilterTouchEventForSecurity方法返回false的话，里面的逻辑全部都走不到直接就返回初始值false了。所以看看onFilterTouchEventForSecurity里面干了什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Filter the touch event to apply security policies.</div><div class="line"> *</div><div class="line"> * @param event The motion event to be filtered.</div><div class="line"> * @return True if the event should be dispatched, false if the event should be dropped.</div><div class="line"> *</div><div class="line"> * @see #getFilterTouchesWhenObscured</div><div class="line"> */</div><div class="line">public boolean onFilterTouchEventForSecurity(MotionEvent event) &#123;</div><div class="line">    //noinspection RedundantIfStatement</div><div class="line">    if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0</div><div class="line">            &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) &#123;</div><div class="line">        // Window is obscured, drop this touch.</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看注释是出于安全的考虑，如果view被遮挡的话直接过滤该事件。</p>
<p>如果没有被遮挡的话就走到下面分发的逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">    // Throw away all previous state when starting a new touch gesture.</div><div class="line">    // The framework may have dropped the up or cancel event for the previous gesture</div><div class="line">    // due to an app switch, ANR, or some other state change.</div><div class="line">    //ACTIONN_DOWN事件清除旧的状态，主要是清除mFirstTouchTarget和FLAG_DISALLOW_INTERCEPT标志位</div><div class="line">    cancelAndClearTouchTargets(ev);</div><div class="line">    resetTouchState();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先判断如果是ACTION_DOWN事件就清除旧的状态，因为ACTION_DOWN是事件序列中的第一个事件，在这个时候适合做一些初始化的事情。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private void cancelAndClearTouchTargets(MotionEvent event) &#123;</div><div class="line">    if (mFirstTouchTarget != null) &#123;</div><div class="line">        boolean syntheticEvent = false;</div><div class="line">        if (event == null) &#123;</div><div class="line">            final long now = SystemClock.uptimeMillis();</div><div class="line">            event = MotionEvent.obtain(now, now,</div><div class="line">                    MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0);</div><div class="line">            event.setSource(InputDevice.SOURCE_TOUCHSCREEN);</div><div class="line">            syntheticEvent = true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) &#123;</div><div class="line">            resetCancelNextUpFlag(target.child);</div><div class="line">            //循环给全部TouchTarget链上的View分发cancel事件</div><div class="line">            dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits);</div><div class="line">        &#125;</div><div class="line">        //清空TouchTarget</div><div class="line">        clearTouchTargets();</div><div class="line"></div><div class="line">        if (syntheticEvent) &#123;</div><div class="line">            event.recycle();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>cancelAndClearTouchTargets这个方法作用就是和名字一样，分发cancel事件和清空TouchTargets，分发事件的核心逻辑在dispatchTransformedTouchEvent方法里，我们后面再讨论，先看看后面也调用的clearTouchTargets</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private void clearTouchTargets() &#123;</div><div class="line">    TouchTarget target = mFirstTouchTarget;</div><div class="line">    if (target != null) &#123;</div><div class="line">        do &#123;</div><div class="line">            TouchTarget next = target.next;</div><div class="line">            target.recycle();</div><div class="line">            target = next;</div><div class="line">        &#125; while (target != null);</div><div class="line">        mFirstTouchTarget = null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>逻辑比较简单，就是循环释放TouchTarget。</p>
<p>我们继续看resetTouchState这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private void resetTouchState() &#123;</div><div class="line">    clearTouchTargets();</div><div class="line">    resetCancelNextUpFlag(this);</div><div class="line">    mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</div><div class="line">    mNestedScrollAxes = SCROLL_AXIS_NONE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法最重要的就是清空了FLAG_DISALLOW_INTERCEPT这个标志位，这个标志位非常重要，是子View唯一可以控制父View分发事件的逻辑，后面我们讲到事件拦截的时候再说。这个方法第一步也是调用了clearTouchTargets去清除TouchTarget。</p>
<p>那么这个TouchTarget是个什么东东呢？其实TouchTarget是ViewGroup的一个静态内部类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">private static final class TouchTarget &#123;</div><div class="line">    private static final int MAX_RECYCLED = 32;</div><div class="line">    private static final Object sRecycleLock = new Object[0];</div><div class="line">    private static TouchTarget sRecycleBin;</div><div class="line">    private static int sRecycledCount;</div><div class="line"></div><div class="line">    public static final int ALL_POINTER_IDS = -1; // all ones</div><div class="line"></div><div class="line">    // The touched child view.</div><div class="line">    //消费事件的View</div><div class="line">    public View child;</div><div class="line"></div><div class="line">    // The combined bit mask of pointer ids for all pointers captured by the target.</div><div class="line">    //事件的pointerId</div><div class="line">    public int pointerIdBits;</div><div class="line"></div><div class="line">    // The next target in the target list.</div><div class="line">    //下一个TouchTarget</div><div class="line">    public TouchTarget next;</div><div class="line"></div><div class="line">    private TouchTarget() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static TouchTarget obtain(@NonNull View child, int pointerIdBits) &#123;</div><div class="line">        if (child == null) &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;child must be non-null&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final TouchTarget target;</div><div class="line">        synchronized (sRecycleLock) &#123;</div><div class="line">            if (sRecycleBin == null) &#123;</div><div class="line">                target = new TouchTarget();</div><div class="line">            &#125; else &#123;</div><div class="line">                target = sRecycleBin;</div><div class="line">                sRecycleBin = target.next;</div><div class="line">                 sRecycledCount--;</div><div class="line">                target.next = null;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        target.child = child;</div><div class="line">        target.pointerIdBits = pointerIdBits;</div><div class="line">        return target;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void recycle() &#123;</div><div class="line">        if (child == null) &#123;</div><div class="line">            throw new IllegalStateException(&quot;already recycled once&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        synchronized (sRecycleLock) &#123;</div><div class="line">            if (sRecycledCount &lt; MAX_RECYCLED) &#123;</div><div class="line">                next = sRecycleBin;</div><div class="line">                sRecycleBin = this;</div><div class="line">                sRecycledCount += 1;</div><div class="line">            &#125; else &#123;</div><div class="line">                next = null;</div><div class="line">            &#125;</div><div class="line">            child = null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>TouchTarget在ViewGroup的事件分发中非常重要，里面主要三个属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// The touched child view.</div><div class="line">//消费事件的View</div><div class="line">public View child;</div><div class="line"></div><div class="line">// The combined bit mask of pointer ids for all pointers captured by the target.</div><div class="line">//事件的pointerId</div><div class="line">public int pointerIdBits;</div><div class="line"></div><div class="line">// The next target in the target list.</div><div class="line">//下一个TouchTarget</div><div class="line">public TouchTarget next;</div></pre></td></tr></table></figure></p>
<p>可以看到TouchTarget是一个单链表的结构，这个结构主要是为了处理Android的多点触摸逻辑的，pointerId也是描述多点触摸的，为了简单分析的逻辑，这片文章都是在单点触摸的逻辑下分析的，如果都是单点触摸的话TouchTarget只有一个实例，其中的next是null。</p>
<p>把状态重置了之后我们再继续往下看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">final boolean intercepted;</div><div class="line">if (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">        || mFirstTouchTarget != null) &#123;</div><div class="line">    //子View可以调用getParent().requestDisallowInterceptTouchEvent()这个方法设置父View的FLAG_DISALLOW_INTERCEPT</div><div class="line">    final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</div><div class="line">    if (!disallowIntercept) &#123;</div><div class="line">        //一般都是重写onInterceptTouchEvent来处理是否拦截该事件</div><div class="line">        intercepted = onInterceptTouchEvent(ev);</div><div class="line">        ev.setAction(action); // restore action in case it was changed</div><div class="line">    &#125; else &#123;</div><div class="line">        intercepted = false;</div><div class="line">    &#125;</div><div class="line">&#125; else &#123;</div><div class="line">    // There are no touch targets and this action is not an initial down</div><div class="line">    // so this view group continues to intercept touches.</div><div class="line">    intercepted = true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是处理是否拦截事件的逻辑，如果是ACIONT_DOWN事件或者mFirstTouchTarget不是null的话才进入，否则intercepted就是true了。在内部逻辑里面会检查FLAG_DISALLOW_INTERCEPT这个标志位，这个标志位可以通过requestDisallowInterceptTouchEvent()方法修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123;</div><div class="line"></div><div class="line">    if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) &#123;</div><div class="line">        // We&apos;re already in this state, assume our ancestors are too</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (disallowIntercept) &#123;</div><div class="line">        mGroupFlags |= FLAG_DISALLOW_INTERCEPT;</div><div class="line">    &#125; else &#123;</div><div class="line">        mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Pass it up to our parent</div><div class="line">    if (mParent != null) &#123;</div><div class="line">        mParent.requestDisallowInterceptTouchEvent(disallowIntercept);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果这个标志位被置位，intercepted就是false，否是intercepted就是onInterceptTouchEvent方法的返回值，一般我们都是用过onInterceptTouchEvent这个方法来解决滑动冲突的问题。</p>
<p>如果没有拦截的话，ViewGroup就会把事件分发给子View<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">if (!canceled &amp;&amp; !intercepted) &#123;</div><div class="line"></div><div class="line">    // If the event is targeting accessiiblity focus we give it to the</div><div class="line">    // view that has accessibility focus and if it does not handle it</div><div class="line">    // we clear the flag and dispatch the event to all children as usual.</div><div class="line">    // We are looking up the accessibility focused host to avoid keeping</div><div class="line">    // state since these events are very rare.</div><div class="line">    View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</div><div class="line">            ? findChildWithAccessibilityFocus() : null;</div><div class="line"></div><div class="line">    if (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">            || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</div><div class="line">            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class="line">        final int actionIndex = ev.getActionIndex(); // always 0 for down</div><div class="line">        final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)</div><div class="line">                : TouchTarget.ALL_POINTER_IDS;</div><div class="line"></div><div class="line">        // Clean up earlier touch targets for this pointer id in case they</div><div class="line">        // have become out of sync.</div><div class="line">        removePointersFromTouchTargets(idBitsToAssign);</div><div class="line"></div><div class="line">        final int childrenCount = mChildrenCount;</div><div class="line">        if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;</div><div class="line">            final float x = ev.getX(actionIndex);</div><div class="line">            final float y = ev.getY(actionIndex);</div><div class="line">            // Find a child that can receive the event.</div><div class="line">            // Scan children from front to back.</div><div class="line">            //对全部子View排序</div><div class="line">            final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</div><div class="line">            final boolean customOrder = preorderedList == null</div><div class="line">                    &amp;&amp; isChildrenDrawingOrderEnabled();</div><div class="line">            final View[] children = mChildren;</div><div class="line">            for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</div><div class="line">                final int childIndex = getAndVerifyPreorderedIndex(</div><div class="line">                        childrenCount, i, customOrder);</div><div class="line">                final View child = getAndVerifyPreorderedView(</div><div class="line">                        preorderedList, children, childIndex);</div><div class="line"></div><div class="line">                // If there is a view that has accessibility focus we want it</div><div class="line">                // to get the event first and if not handled we will perform a</div><div class="line">                // normal dispatch. We may do a double iteration but this is</div><div class="line">                // safer given the timeframe.</div><div class="line">                if (childWithAccessibilityFocus != null) &#123;</div><div class="line">                    if (childWithAccessibilityFocus != child) &#123;</div><div class="line">                        continue;</div><div class="line">                    &#125;</div><div class="line">                    childWithAccessibilityFocus = null;</div><div class="line">                    i = childrenCount - 1;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                //判断这个View能否接收这个事件，判断依据是View是否可见或者正在动画中而且触摸事件的坐标在View位置上</div><div class="line">                if (!canViewReceivePointerEvents(child)</div><div class="line">                        || !isTransformedTouchPointInView(x, y, child, null)) &#123;</div><div class="line">                    ev.setTargetAccessibilityFocus(false);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                newTouchTarget = getTouchTarget(child);</div><div class="line">                if (newTouchTarget != null) &#123;</div><div class="line">                    // Child is already receiving touch within its bounds.</div><div class="line">                    // Give it the new pointer in addition to the ones it is handling.</div><div class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                resetCancelNextUpFlag(child);</div><div class="line">                //将事件分发给子View</div><div class="line">                if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</div><div class="line">                    // Child wants to receive touch within its bounds.</div><div class="line">                    mLastTouchDownTime = ev.getDownTime();</div><div class="line">                    if (preorderedList != null) &#123;</div><div class="line">                        // childIndex points into presorted list, find original index</div><div class="line">                        for (int j = 0; j &lt; childrenCount; j++) &#123;</div><div class="line">                            if (children[childIndex] == mChildren[j]) &#123;</div><div class="line">                                mLastTouchDownIndex = j;</div><div class="line">                                break;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        mLastTouchDownIndex = childIndex;</div><div class="line">                    &#125;</div><div class="line">                    mLastTouchDownX = ev.getX();</div><div class="line">                    mLastTouchDownY = ev.getY();</div><div class="line">                    //如果子View处理了该事件，则对newTouchTarget和mFirstTouchTarget赋值</div><div class="line">                    newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">                    //alreadyDispatchedToNewTouchTarget赋值为true</div><div class="line">                    alreadyDispatchedToNewTouchTarget = true;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // The accessibility focus didn&apos;t handle the event, so clear</div><div class="line">                // the flag and do a normal dispatch to all children.</div><div class="line">                ev.setTargetAccessibilityFocus(false);</div><div class="line">            &#125;</div><div class="line">            if (preorderedList != null) preorderedList.clear();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123;</div><div class="line">            // Did not find a child to receive the event.</div><div class="line">            // Assign the pointer to the least recently added target.</div><div class="line">            newTouchTarget = mFirstTouchTarget;</div><div class="line">            while (newTouchTarget.next != null) &#123;</div><div class="line">                newTouchTarget = newTouchTarget.next;</div><div class="line">            &#125;</div><div class="line">            newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先分发事件给子View，首先就需要找出全部子View，但是子View有可能有很多个，但是事件只有一个，只能给一个子View处理，所以要对全部子View进行排序，按顺序判断是否该子View能否处理该事件，如果有子View处理了这个事件，那么后续的子View就得不到处理的机会了。排序的方法是buildTouchDispatchChildList()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public ArrayList&lt;View&gt; buildTouchDispatchChildList() &#123;</div><div class="line">    return buildOrderedChildList();</div><div class="line">&#125;</div><div class="line"></div><div class="line">ArrayList&lt;View&gt; buildOrderedChildList() &#123;</div><div class="line">    final int childrenCount = mChildrenCount;</div><div class="line">    if (childrenCount &lt;= 1 || !hasChildWithZ()) return null;</div><div class="line"></div><div class="line">    if (mPreSortedChildren == null) &#123;</div><div class="line">        mPreSortedChildren = new ArrayList&lt;&gt;(childrenCount);</div><div class="line">    &#125; else &#123;</div><div class="line">        // callers should clear, so clear shouldn&apos;t be necessary, but for safety...</div><div class="line">        mPreSortedChildren.clear();</div><div class="line">        mPreSortedChildren.ensureCapacity(childrenCount);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    final boolean customOrder = isChildrenDrawingOrderEnabled();</div><div class="line">    for (int i = 0; i &lt; childrenCount; i++) &#123;</div><div class="line">        // add next child (in child order) to end of list</div><div class="line">        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</div><div class="line">        final View nextChild = mChildren[childIndex];</div><div class="line">        final float currentZ = nextChild.getZ();</div><div class="line"></div><div class="line">        // insert ahead of any Views with greater Z</div><div class="line">        int insertIndex = i;</div><div class="line">        //插入排序，Z小的在低位</div><div class="line">        while (insertIndex &gt; 0 &amp;&amp; mPreSortedChildren.get(insertIndex - 1).getZ() &gt; currentZ) &#123;</div><div class="line">            insertIndex--;</div><div class="line">        &#125;</div><div class="line">        mPreSortedChildren.add(insertIndex, nextChild);</div><div class="line">    &#125;</div><div class="line">    return mPreSortedChildren;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一般情况下排序的是根据xml中定义的顺序或者addView的顺序来决定的，但是Android也提供了自定义排序的方法。</p>
<p>当全部子View拍好序之后，从后往前分发数据，怎么判断View能否处理这个事件呢？Android是通过两个方法判断的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">if (!canViewReceivePointerEvents(child)</div><div class="line">        || !isTransformedTouchPointInView(x, y, child, null)) &#123;</div><div class="line">    ev.setTargetAccessibilityFocus(false);</div><div class="line">    continue;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//可见或者正在执行动画的</div><div class="line">private static boolean canViewReceivePointerEvents(@NonNull View child) &#123;</div><div class="line">    return (child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE</div><div class="line">            || child.getAnimation() != null;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//触摸事件的坐标在子View的布局范围中返回true</div><div class="line">protected boolean isTransformedTouchPointInView(float x, float y, View child,</div><div class="line">        PointF outLocalPoint) &#123;</div><div class="line">    final float[] point = getTempPoint();</div><div class="line">    point[0] = x;</div><div class="line">    point[1] = y;</div><div class="line">    transformPointToViewLocal(point, child);</div><div class="line">    final boolean isInView = child.pointInView(point[0], point[1]);</div><div class="line">    if (isInView &amp;&amp; outLocalPoint != null) &#123;</div><div class="line">        outLocalPoint.set(point[0], point[1]);</div><div class="line">    &#125;</div><div class="line">    return isInView;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简单来说就是子View是可见的，而且触摸事件的坐标是在子View的布局范围的。只有同时满足了这两个条件，这个子View才有可能处理这个事件。</p>
<p>满足了上面的条件后，ViewGroup就会把事件分发给子View<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</div><div class="line">    // Child wants to receive touch within its bounds.</div><div class="line">    mLastTouchDownTime = ev.getDownTime();</div><div class="line">    if (preorderedList != null) &#123;</div><div class="line">        // childIndex points into presorted list, find original index</div><div class="line">        for (int j = 0; j &lt; childrenCount; j++) &#123;</div><div class="line">            if (children[childIndex] == mChildren[j]) &#123;</div><div class="line">                mLastTouchDownIndex = j;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        mLastTouchDownIndex = childIndex;</div><div class="line">    &#125;</div><div class="line">    mLastTouchDownX = ev.getX();</div><div class="line">    mLastTouchDownY = ev.getY();</div><div class="line">    newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">    alreadyDispatchedToNewTouchTarget = true;</div><div class="line">    break;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>dispatchTransformedTouchEvent是执行分发的逻辑，我们看看这个方法内部干了什么事情<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</div><div class="line">        View child, int desiredPointerIdBits) &#123;</div><div class="line">    final boolean handled;</div><div class="line"></div><div class="line">    // Canceling motions is a special case.  We don&apos;t need to perform any transformations</div><div class="line">    // or filtering.  The important part is the action, not the contents.</div><div class="line">    final int oldAction = event.getAction();</div><div class="line">    </div><div class="line">    //如果cancel是true，则把事件修改为ACTION_DOWN</div><div class="line">    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</div><div class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</div><div class="line">        if (child == null) &#123;</div><div class="line">            //如果child为null，则交给父类(View)的dispatchTouchEvent处理</div><div class="line">            handled = super.dispatchTouchEvent(event);</div><div class="line">        &#125; else &#123;</div><div class="line">            //分发给子View</div><div class="line">            handled = child.dispatchTouchEvent(event);</div><div class="line">        &#125;</div><div class="line">        event.setAction(oldAction);</div><div class="line">        return handled;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Calculate the number of pointers to deliver.</div><div class="line">    final int oldPointerIdBits = event.getPointerIdBits();</div><div class="line">    final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</div><div class="line"></div><div class="line">    // If for some reason we ended up in an inconsistent state where it looks like we</div><div class="line">    // might produce a motion event with no pointers in it, then drop the event.</div><div class="line">    if (newPointerIdBits == 0) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // If the number of pointers is the same and we don&apos;t need to perform any fancy</div><div class="line">    // irreversible transformations, then we can reuse the motion event for this</div><div class="line">    // dispatch as long as we are careful to revert any changes we make.</div><div class="line">    // Otherwise we need to make a copy.</div><div class="line">    final MotionEvent transformedEvent;</div><div class="line">    if (newPointerIdBits == oldPointerIdBits) &#123;</div><div class="line">        if (child == null || child.hasIdentityMatrix()) &#123;</div><div class="line">            if (child == null) &#123;</div><div class="line">                handled = super.dispatchTouchEvent(event);</div><div class="line">            &#125; else &#123;</div><div class="line">                final float offsetX = mScrollX - child.mLeft;</div><div class="line">                final float offsetY = mScrollY - child.mTop;</div><div class="line">                event.offsetLocation(offsetX, offsetY);</div><div class="line"></div><div class="line">                handled = child.dispatchTouchEvent(event);</div><div class="line"></div><div class="line">                event.offsetLocation(-offsetX, -offsetY);</div><div class="line">            &#125;</div><div class="line">            return handled;</div><div class="line">        &#125;</div><div class="line">        transformedEvent = MotionEvent.obtain(event);</div><div class="line">    &#125; else &#123;</div><div class="line">        transformedEvent = event.split(newPointerIdBits);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Perform any necessary transformations and dispatch.</div><div class="line">    if (child == null) &#123;</div><div class="line">        handled = super.dispatchTouchEvent(transformedEvent);</div><div class="line">    &#125; else &#123;</div><div class="line">        final float offsetX = mScrollX - child.mLeft;</div><div class="line">        final float offsetY = mScrollY - child.mTop;</div><div class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</div><div class="line">        if (! child.hasIdentityMatrix()) &#123;</div><div class="line">            transformedEvent.transform(child.getInverseMatrix());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        handled = child.dispatchTouchEvent(transformedEvent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Done.</div><div class="line">    transformedEvent.recycle();</div><div class="line">    return handled;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码有点长，但是逻辑比较简单，需要注意的有两点</p>
<ul>
<li>第二个参数cancel为true的时候，会把当前分发的事件修改为DOWN事件</li>
<li>如果第三个参数child为null，分发的时候就把事件交给父类的dispatchTouchEvent处理，ViewGroup的父类也就是View类。</li>
</ul>
<p>我们再看看这个方法的返回值，如果dispatchTransformedTouchEvent方法返回了true，证明子View处理了这个事件，就调用了addTouchTarget方法给newTouchTarget赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newTouchTarget = addTouchTarget(child, idBitsToAssign);</div></pre></td></tr></table></figure></p>
<p>在addTouchTarget内部又对mFirstTouchTarget赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123;</div><div class="line">    final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</div><div class="line">    target.next = mFirstTouchTarget;</div><div class="line">    mFirstTouchTarget = target;</div><div class="line">    return target;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果子View处理了该事件就退出分发，否则遍历全部的子View。</p>
<p>最后一部分逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// Dispatch to touch targets.</div><div class="line">//如果没有子View处理该事件则自己处理，注意第三个参数是null</div><div class="line">if (mFirstTouchTarget == null) &#123;</div><div class="line">    // No touch targets so treat this as an ordinary view.</div><div class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, null,</div><div class="line">            TouchTarget.ALL_POINTER_IDS);</div><div class="line">&#125; else &#123;</div><div class="line">    // Dispatch to touch targets, excluding the new touch target if we already</div><div class="line">    // dispatched to it.  Cancel touch targets if necessary.</div><div class="line">    TouchTarget predecessor = null;</div><div class="line">    TouchTarget target = mFirstTouchTarget;</div><div class="line">    while (target != null) &#123;</div><div class="line">        final TouchTarget next = target.next;</div><div class="line">        if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</div><div class="line">            handled = true;</div><div class="line">        &#125; else &#123;</div><div class="line">            final boolean cancelChild = resetCancelNextUpFlag(target.child)</div><div class="line">                    || intercepted;</div><div class="line">                    //继续分发事件</div><div class="line">            if (dispatchTransformedTouchEvent(ev, cancelChild,</div><div class="line">                    target.child, target.pointerIdBits)) &#123;</div><div class="line">                handled = true;</div><div class="line">            &#125;</div><div class="line">            if (cancelChild) &#123;</div><div class="line">                if (predecessor == null) &#123;</div><div class="line">                    mFirstTouchTarget = next;</div><div class="line">                &#125; else &#123;</div><div class="line">                    predecessor.next = next;</div><div class="line">                &#125;</div><div class="line">                target.recycle();</div><div class="line">                target = next;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        predecessor = target;</div><div class="line">        target = next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果前面分发的时候没有子View，或者子View没有处理事件，那么mFirstTarget就是null，调用了dispatchTransformedTouchEvent()方法去分发，注意第三个参数child是null，在前面的分析知道，如果child是null的话就会调用父类View的dispatchTouchEvent方法，也就是说把ViewGroup当成了View，把事件交给了ViewGroup自己处理。</p>
<p>如果有子View处理的话会走到下面一个分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</div><div class="line">    handled = true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">  public boolean dispatchTouchEvent(MotionEvent event) &#123;</div><div class="line">      // If the event should be handled by accessibility focus first.</div><div class="line">      if (event.isTargetAccessibilityFocus()) &#123;</div><div class="line">          // We don&apos;t have focus or no virtual descendant has it, do not handle the event.</div><div class="line">          if (!isAccessibilityFocusedViewOrHost()) &#123;</div><div class="line">              return false;</div><div class="line">          &#125;</div><div class="line">          // We have focus and got the event, then use normal event dispatch.</div><div class="line">          event.setTargetAccessibilityFocus(false);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      boolean result = false;</div><div class="line"></div><div class="line">      if (mInputEventConsistencyVerifier != null) &#123;</div><div class="line">          mInputEventConsistencyVerifier.onTouchEvent(event, 0);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      final int actionMasked = event.getActionMasked();</div><div class="line">      if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">          // Defensive cleanup for new gesture</div><div class="line">          stopNestedScroll();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">//和ViewGroup一样的逻辑，View被遮挡了就过滤事件</div><div class="line">      if (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">          //轨迹球</div><div class="line">          if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</div><div class="line">              result = true;</div><div class="line">          &#125;</div><div class="line">          //noinspection SimplifiableIfStatement</div><div class="line">	//如果有onTouchListener就调用onTouchListener的onTouch方法</div><div class="line">          ListenerInfo li = mListenerInfo;</div><div class="line">          if (li != null &amp;&amp; li.mOnTouchListener != null</div><div class="line">                  &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">                  &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</div><div class="line">              result = true;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">	//如果前面都没处理，就调用自己的OnTouchEvent</div><div class="line">          if (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class="line">              result = true;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123;</div><div class="line">          mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // Clean up after nested scrolls if this is the end of a gesture;</div><div class="line">      // also cancel it if we tried an ACTION_DOWN but we didn&apos;t want the rest</div><div class="line">      // of the gesture.</div><div class="line">      if (actionMasked == MotionEvent.ACTION_UP ||</div><div class="line">              actionMasked == MotionEvent.ACTION_CANCEL ||</div><div class="line">              (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</div><div class="line">          stopNestedScroll();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      return result;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>View的dispatchTouchEvent方法比ViewGroup的简单多了，毕竟不需要继续往下分发，先是调用了和起那么ViewGroup一样的onFilterTouchEventForSecurity方法做安全校验。</p>
<p>先交给轨迹球处理，如果轨迹球不处理的话判断是否有OnTouchListener，如果都不处理的话就调用自己的onTouchEvent。流程非常简单，那我们在看看onTouchEvent方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div></pre></td><td class="code"><pre><div class="line">  public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">      final float x = event.getX();</div><div class="line">      final float y = event.getY();</div><div class="line">      final int viewFlags = mViewFlags;</div><div class="line">      final int action = event.getAction();</div><div class="line"></div><div class="line">      final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</div><div class="line">              || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</div><div class="line">              || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</div><div class="line"></div><div class="line">      if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class="line">          if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;</div><div class="line">              setPressed(false);</div><div class="line">          &#125;</div><div class="line">          mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</div><div class="line">          // A disabled view that is clickable still consumes the touch</div><div class="line">          // events, it just doesn&apos;t respond to them.</div><div class="line">	//如果View是disable的，那么返回值由clickable(CLICKABLE || LONG_CLICKABLE || CONTEXT_CLICKABLE)决定</div><div class="line">          return clickable;</div><div class="line">      &#125;</div><div class="line">      if (mTouchDelegate != null) &#123;</div><div class="line">          if (mTouchDelegate.onTouchEvent(event)) &#123;</div><div class="line">              return true;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">//如果view是clickable的，默认消费该事件</div><div class="line">      if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</div><div class="line">          switch (action) &#123;</div><div class="line">              case MotionEvent.ACTION_UP:</div><div class="line">                  mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</div><div class="line">                  if ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</div><div class="line">                      handleTooltipUp();</div><div class="line">                  &#125;</div><div class="line">                  if (!clickable) &#123;</div><div class="line">                      removeTapCallback();</div><div class="line">                      removeLongPressCallback();</div><div class="line">                      mInContextButtonPress = false;</div><div class="line">                      mHasPerformedLongPress = false;</div><div class="line">                      mIgnoreNextUpEvent = false;</div><div class="line">                      break;</div><div class="line">                  &#125;</div><div class="line">                  boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;</div><div class="line">                  if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123;</div><div class="line">                      // take focus if we don&apos;t have it already and we should in</div><div class="line">                      // touch mode.</div><div class="line">                      boolean focusTaken = false;</div><div class="line">                      if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</div><div class="line">                          focusTaken = requestFocus();</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      if (prepressed) &#123;</div><div class="line">                          // The button is being released before we actually</div><div class="line">                          // showed it as pressed.  Make it show the pressed</div><div class="line">                          // state now (before scheduling the click) to ensure</div><div class="line">                          // the user sees it.</div><div class="line">					//虽然手指已经抬起了，但是先设置成按下状态，让用户可以看到被按下的状态</div><div class="line">                          setPressed(true, x, y);</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</div><div class="line">                          // This is a tap, so remove the longpress check</div><div class="line">                          removeLongPressCallback();</div><div class="line"></div><div class="line">                          // Only perform take click actions if we were in the pressed state</div><div class="line">                          if (!focusTaken) &#123;</div><div class="line">                              // Use a Runnable and post this rather than calling</div><div class="line">                              // performClick directly. This lets other visual state</div><div class="line">                              // of the view update before click actions start.</div><div class="line">                              if (mPerformClick == null) &#123;</div><div class="line">                                  mPerformClick = new PerformClick();</div><div class="line">                              &#125;</div><div class="line">                              if (!post(mPerformClick)) &#123;</div><div class="line">                                  performClick();</div><div class="line">                              &#125;</div><div class="line">                          &#125;</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      if (mUnsetPressedState == null) &#123;</div><div class="line">                          mUnsetPressedState = new UnsetPressedState();</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">				//取消pressed状态</div><div class="line">                      if (prepressed) &#123;</div><div class="line">                          postDelayed(mUnsetPressedState,</div><div class="line">                                  ViewConfiguration.getPressedStateDuration());</div><div class="line">                      &#125; else if (!post(mUnsetPressedState)) &#123;</div><div class="line">                          // If the post failed, unpress right now</div><div class="line">                          mUnsetPressedState.run();</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      removeTapCallback();</div><div class="line">                  &#125;</div><div class="line">                  mIgnoreNextUpEvent = false;</div><div class="line">                  break;</div><div class="line"></div><div class="line">              case MotionEvent.ACTION_DOWN:</div><div class="line">                  if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123;</div><div class="line">                      mPrivateFlags3 |= PFLAG3_FINGER_DOWN;</div><div class="line">                  &#125;</div><div class="line">                  mHasPerformedLongPress = false;</div><div class="line"></div><div class="line">			</div><div class="line">                  //这里不明白为什么不是clickable的还要去检查长按事件</div><div class="line">                  if (!clickable) &#123;</div><div class="line">                      checkForLongClick(0, x, y);</div><div class="line">                      break;</div><div class="line">                  &#125;</div><div class="line"></div><div class="line">                  if (performButtonActionOnTouchDown(event)) &#123;</div><div class="line">                      break;</div><div class="line">                  &#125;</div><div class="line"></div><div class="line">                  // Walk up the hierarchy to determine if we&apos;re inside a scrolling container.</div><div class="line">			//判断是不是在可以滚动的容器中</div><div class="line">                  boolean isInScrollingContainer = isInScrollingContainer();</div><div class="line"></div><div class="line">                  // For views inside a scrolling container, delay the pressed feedback for</div><div class="line">                  // a short period in case this is a scroll.</div><div class="line">                  if (isInScrollingContainer) &#123;</div><div class="line">                      mPrivateFlags |= PFLAG_PREPRESSED;</div><div class="line">                      if (mPendingCheckForTap == null) &#123;</div><div class="line">                          mPendingCheckForTap = new CheckForTap();</div><div class="line">                      &#125;</div><div class="line">                      mPendingCheckForTap.x = event.getX();</div><div class="line">                      mPendingCheckForTap.y = event.getY();</div><div class="line">				//延时检测长按</div><div class="line">                      postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</div><div class="line">                  &#125; else &#123;</div><div class="line">                      // Not inside a scrolling container, so show the feedback right away</div><div class="line">				//设置pressed状态</div><div class="line">                      setPressed(true, x, y);</div><div class="line">				//检测长按</div><div class="line">                      checkForLongClick(0, x, y);</div><div class="line">                  &#125;</div><div class="line">                  break;</div><div class="line"></div><div class="line">              case MotionEvent.ACTION_CANCEL:</div><div class="line">			//cancel的时候移除回调，重置状态</div><div class="line">                  if (clickable) &#123;</div><div class="line">                      setPressed(false);</div><div class="line">                  &#125;</div><div class="line">                  removeTapCallback();</div><div class="line">                  removeLongPressCallback();</div><div class="line">                  mInContextButtonPress = false;</div><div class="line">                  mHasPerformedLongPress = false;</div><div class="line">                  mIgnoreNextUpEvent = false;</div><div class="line">                  mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</div><div class="line">                  break;</div><div class="line"></div><div class="line">              case MotionEvent.ACTION_MOVE:</div><div class="line">                  if (clickable) &#123;</div><div class="line">                      drawableHotspotChanged(x, y);</div><div class="line">                  &#125;</div><div class="line"></div><div class="line">			//检测触摸坐标是否移动到View外部</div><div class="line">                  // Be lenient about moving outside of buttons</div><div class="line">                  if (!pointInView(x, y, mTouchSlop)) &#123;</div><div class="line">                      // Outside button</div><div class="line">                      // Remove any future long press/tap checks</div><div class="line">				//移除点击回调</div><div class="line">                      removeTapCallback();</div><div class="line">                      removeLongPressCallback();</div><div class="line">                      if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;</div><div class="line">					//重置pressed状态</div><div class="line">                          setPressed(false);</div><div class="line">                      &#125;</div><div class="line">                      mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</div><div class="line">                  &#125;</div><div class="line">                  break;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          return true;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      return false;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里的逻辑还是比较绕的，但是返回值比较明确，如果View是clickable或者long clickable的话，返回true，否则返回false。</p>
<p>整个事件的分发逻辑就完成了。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/View/" rel="tag"># View</a>
          
            <a href="/tags/Event-Dispatch/" rel="tag"># Event Dispatch</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/View源码了解一下，Draw过程/" rel="next" title="View源码了解一下，Draw过程">
                <i class="fa fa-chevron-left"></i> View源码了解一下，Draw过程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/Android中的ClassLoader/" rel="prev" title="Android中的ClassLoader">
                Android中的ClassLoader <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpeg"
               alt="brainBear" />
          <p class="site-author-name" itemprop="name">brainBear</p>
          <p class="site-description motion-element" itemprop="description">多写代码 少写Bug</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">50</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Activity"><span class="nav-number">1.</span> <span class="nav-text">Activity</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ViewGroup"><span class="nav-number">2.</span> <span class="nav-text">ViewGroup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View"><span class="nav-number">3.</span> <span class="nav-text">View</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">brainBear</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid="></script>
      <!-- UY END -->
  




  
  

  

  

  

  


</body>
</html>
